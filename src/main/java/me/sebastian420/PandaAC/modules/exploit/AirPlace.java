package me.sebastian420.PandaAC.modules.exploit;

import me.sebastian420.PandaAC.LoggerThread;
import net.minecraft.block.Blocks;
import net.minecraft.util.ActionResult;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.World;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.block.BlockState;
import net.fabricmc.fabric.api.event.player.UseBlockCallback;
import net.fabricmc.fabric.api.event.player.PlayerBlockBreakEvents;
public class AirPlace {

    private static double dotProduct(Vec3d v1, Vec3d v2) {
        return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
    }

    // Hook into the block placement event and run validation code
    public static void hookBlockPlacementEvent() {
        UseBlockCallback.EVENT.register((player, world, hand, hitResult) -> {
            // Get the position of the block being placed
            BlockPos pos = hitResult.getBlockPos().offset(hitResult.getSide());
            BlockPos playerPos = player.getBlockPos();
            double distance = playerPos.getSquaredDistance(pos.getX(), pos.getY(), pos.getZ());

            // Get the block face direction and the player's looking direction
            Direction faceDirection = hitResult.getSide();
            Vec3d lookDirection = player.getRotationVec(1.0F);

            // Check the angle between the face direction and the player's looking direction
            double angle = Math.toDegrees(Math.acos(dotProduct(Vec3d.of(faceDirection.getVector()), lookDirection.normalize())));
            if (angle < 90) {
                // If the angle is too large, cancel the placement
                return ActionResult.FAIL;
            }

            // Run validation code before placing the block
            if (!isValidBlockPlacement(world, pos) || distance > 60) {
                // If the block placement is invalid, cancel the placement
                return ActionResult.FAIL;
            }

            // If the block placement is valid, allow the placement to proceed
            return ActionResult.PASS;
        });
        PlayerBlockBreakEvents.BEFORE.register((world, player, pos, state, blockEntity) -> {
            // Check if the player is within reach of the block
            BlockPos playerPos = player.getBlockPos();
            double distance = playerPos.getSquaredDistance(pos.getX(), pos.getY(), pos.getZ());
            if (distance > 60 ){
                // Player is not within reach of the block, cancel the event
                return false;
            }
            // Player is within reach of the block, allow the event to proceed
            return true;
        });

    }


    // Check if the block at the given position is connected to another solid block
    public static boolean isValidBlockPlacement(World world, BlockPos pos) {
        // Get the state of the block being placed
        BlockState state = world.getBlockState(pos);


        // Check if the block is connected to another solid block
        for (Direction dir : Direction.values()) {
            BlockPos neighborPos = pos.offset(dir);
            BlockState neighborState = world.getBlockState(neighborPos);



            if (!neighborState.isAir() && neighborState.getFluidState().isEmpty()) {
                return true;
            }
        }

        // The block is not connected to another solid block
        return false;
    }



}